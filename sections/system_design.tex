\chapter{System Design}



\section{System Overview}
As a means to both explaining the system and as a practical development model,
the system can be thought of as being made up of layers.
Each layer being an abstraction of workings in the layers beneath it,
with the partitions at the top and the hardware at the bottom.
This model is defined by the ARINC 653 standard
\todo[inline,color=green]{Insert ref to analysis of ARINC.}
and expanded upon here with drivers being build on top of the HAL library,
instead of directly on top of the hardware,
creating an extra layer of abstraction.

\begin{itemize}
	\item \textbf{Partitions}
		are running the applications which defines how the system interacts
		with the system around it.
		Doing so in complete isolation from one another.
	\item \textbf{APEX}
		defines the methods by which the partitions talk to the world and
		interacts with other partitions or systems, running
		on the same chip or otherwise connected.
	\item \textbf{OS}
		provides the infrastructure of partitions to operate and
		including scheduling.
	\item \textbf{Drivers}
		serves the OS with methods to create an enviroment in which partitions
		can be run and scheduled without affection one another.
	\item \textbf{HAL}
		An abstraction layer provided by the chip manufacturer,
		to make setting up the hardware easier on developers.
	\item \textbf{Hardware}
		The physical platform on which everything is executed.
\end{itemize}

An XML file is provided by the system developer at compile time.
It defines how the top layers interact and set the requirements of the drivers
and the underlying hardware.

Every layer contains a list of components, which provides the functionalities
of that layer.
Beneath graphical overview of the different layers with their core components
is provided.

\includegraphics[width=13cm]{first_draft_sys_design_diag.jpeg}

In the rest of the chapter the different layers are described with their core
components together with an overall view in the specifications for the hardware
and the XML.


\subsection{Hardware}

\subsection{Drivers}
\begin{description}[align=left]
	\item [\textbf{UART driver}] The UART is used by the system to communicate with the outside
	world. This can either receive or transmit data to another UART device.
	\item [\textbf{Watchdog timer driver}] The watchdog timer is necessary to ensure recovery
	in case of a hardware fault or program error. If this happens, the program would be restarted
	from a safe state.

\end{description}

\subsection{OS}
\subsubsection{Scheduler}
Here we have some nice text about the scheduler(s).

\paragraph{Context switching} is an absolute necessity in a multitasking operating system.
Context switching works by dumping the CPU registers from one context to memory,
and then switching to another context by restoring the registers from another dump.
Since context switching must manipulate registers directly and individually, it is a feature that must be implemented
on a very low level of abstraction, and it can change significantly from one CPU architecture to another.
The scope of this project is to only implement an operating system for a Cortex M4. Hence context switching needs only
to work on the architecture used by this chip.\\
Context Switching on the Cortex M4 is partially handled by the Nested Vectored Interrupt Controller (NVIC).
When an exception (this includes interrupts) occurs, the NVIC will change context to an exception handler.
Upon changing context from regular code to the exception handler, the NVIC will save the registers R0-R3, R12, LR, PC and PSR
on the stack. These are only some of the registers. Why the decision was made to make the hardware save some of the 
registers instead of letting software handle all, is unknown. \todo{Research harder the reason why the NVIC saves some register.}
When the exception handling routine exits, and control is handed back to the NVIC,
the NVIC will restore these registers again.\\
If the operating system wishes to switch context, it must save the remaining registers, R4-R11, and the stack pointer to memory 
pick a new context to restore, reload the registers R4-R11 and the stack pointer of the new context from memory,
and hand back control to the NVIC. The NVIC will then reload the remaining registers from the stack of the new context.\\\\
As added complexity, the Cortex M4 utilises two different stack pointers, the Master Stack Pointer (MSP) and the Process Stack Pointer (PSP).
The MSP is intended for kernel space execution and the PSP is intended for user space execution, but there is no enforcement.
Switching between the two cannot be done in an exception handler, but must instead be done by the NVIC.
The way to communicate which stack pointer to use with the NVIC, is to load the Program Counter register with a certain value (see EXC\_RETURN values). 


\subsubsection{Interpartition communication}

\section{XML}


\section{Memory Management}
ARINC 653 advertizes time and space seperation covered in (ref to sec in analysis).
To accommodate for the feature of seperating partitions in space
this operating system relies on the memory management unit (MPU)
to manage permissions accross sections of memory
ensuring that partitions stay within a dedicated memory space.

\subsection{something about ARINC on memory management}

\subsection{the MPU on a STM32F415}

\subsection{memory strategy}
