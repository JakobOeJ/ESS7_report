\chapter{System Design}

In this chapter the project is further analysed, with diagrams, delimitation...
\todo[inline,color=green]{Maybe write some more.}

\section{System Overview}
As a means to both explaining the system and as a practical development model,
the system can be thought of as being made up of layers.
Each layer being an abstraction of workings in the layers beneath it,
with the partitions at the top and the hardware at the bottom.
This model is defined by the ARINC 653 standard
\todo[inline,color=green]{Insert ref to analysis of ARINC.}
and expanded upon here with drivers being build on top of the HAL library,
instead of directly on top of the hardware,
creating an extra layer of abstraction.

\begin{itemize}
	\item \textbf{Partitions}
		are running the applications which defines how the system interacts
		with the system around it.
		Doing so in complete isolation from one another.
	\item \textbf{APEX}
		defines the methods by which the partitions talk to the world and
		interacts with other partitions or systems, running
		on the same chip or otherwise connected.
	\item \textbf{OS}
		provides the infrastructure of partitions to operate and
		including scheduling.
	\item \textbf{Drivers}
		serves the OS with methods to create an enviroment in which partitions
		can be run and scheduled without affection one another.
	\item \textbf{HAL}
		An abstraction layer provided by the chip manufacturer,
		to make setting up the hardware easier on developers.
	\item \textbf{Hardware}
		The physical platform on which everything is executed.
\end{itemize}

An XML file is provided by the system developer at compile time.
It defines how the top layers interact and set the requirements of the drivers
and the underlying hardware.

Every layer contains a list of components, which provides the functionalities
of that layer.
Beneath graphical overview of the different layers with their core components
is provided.

\includegraphics[width=3cm]{first_draft_sys_design_diag.jpeg}
\todo[inline,color=green]{New figure}
\includegraphics[width=\textwidth,height=\textheight,keepaspectratio]{advanced_system_architecture.pdf}

In the rest of the chapter the different layers are described with their core
components together with an overall view in the specifications for the hardware
and the XML.

\subsection{Hardware}

\subsection{Drivers}
\begin{description}[align=left]
	\item [\textbf{UART driver}] The UART is used by the system to communicate with the outside
	world. This can either receive or transmit data to another UART device.
	\item [\textbf{Watchdog timer driver}] The watchdog timer is necessary to ensure recovery
	in case of a hardware fault or program error. If this happens, the program would be restarted
	from a safe state.

\end{description}

\subsection{OS}
\subsubsection{Scheduler}
A scheduler decides which process should be executed by the processor available, according to some rules. In this implementation we have 2 levels of scheduling, one to switch between partitions and a second one for processing the processes of each partition.

For the first one we used a Manual Scheduler, that gives a certain amount of time of processor to each partition, according to its demand and importance. Those values can't be changed in running time, following the same rules during the whole execution. Every milisecond we verify if the time of the partition running has reached the timeout, if so, we switch the context for the next partition. And the new partition gets the processor.

The second one is a Preemtive Priority Scheduler, based on the processes' priority, in which is executed the one with the highest priority until it loses the processor to other partition. Every milisecond we pick the process, from the array of processes of that partition, with the highest priority and run in the processor.

\paragraph{Context switching} is to switch from executing one block of code $b_1$ to another block of code $b_2$
with the intend to eventually return to $b_1$ in a way that is transparent to the blocks of code.
This allows for code to be partitioned into separate independent blocks that can run concurrently.
This is opposed to monolithic blocks of code that entirely control the flow of execution.
Therefore, context switching is essential for any operating system that wishes to utilise a scheduler to allow concurrent execution of code.
Context switching works by saving the state of the CPU registers from one context to memory,
and then switching to another context by restoring the state of the registers previously saved in memory.
Since context switching must manipulate registers directly and individually, it is a feature that must be implemented
on a very low level of abstraction, and it can change significantly from one CPU architecture to another.
The scope of this project is to only implement an operating system for a Cortex M4. Hence context switching needs only
to work on the architecture used by this chip.\\
Context Switching on the Cortex M4 is partially handled by the Nested Vectored Interrupt Controller (NVIC).
When an exception (this includes interrupts) occurs, the NVIC will change context to an exception handler.
Upon changing context from regular code to the exception handler, the NVIC will save the registers R0-R3, R12, LR, PC and PSR
on the stack. These are only some of the registers. Why the decision was made to make the hardware save some of the
registers instead of letting software handle all, is unknown. \todo{Research harder the reason why the NVIC saves some register.}
When the exception handling routine exits, and control is handed back to the NVIC,
the NVIC will restore these registers again.\\
If the operating system wishes to switch context, it must save the remaining registers, R4-R11, and the stack pointer to memory
pick a new context to restore, reload the registers R4-R11 and the stack pointer of the new context from memory,
and hand back control to the NVIC. The NVIC will then reload the remaining registers from the stack of the new context. To see a figure of the registers and who saves them, see figure \ref{tab:registers}\\\\
\begin{figure}
	\centering
	\begin{tabular}{|c|c|p{9.5cm}|}
		\hline
		Register	&	Saved by	&	Purpose\\
		\hline
		R0			&	Hardware	&	General purpose (Argument value + return value)\\
		\hline
		R1-R3		&	Hardware	&	General purpose (Argument value)\\
		\hline
		R4-R11		&	Software	&	General purpose (Local variable)\\
		\hline
		R12			&	Hardware	&	General purpose (Intra-Procedure-call scratch)\\
		\hline
		R13 (SP)	&	Software	&	Stack pointer [Banked]\\
		MSP			&	Software	&	Master stack pointer (Stack pointer for kernel space)\\
		PSP			&	Software	&	Process stack pointer (Stack pointer for user space)\\
		\hline
		R14 (LR)	&	Hardware	&	Link register\\
		\hline
		R15 (PC)	&	Hardware	&	Program Counter\\
		\hline
		xPSR		&	Hardware	& 	Special-purpose Program Status Register\\
		\hline
	\end{tabular}
	\caption{A table of the CPU registers of a Cortex M4. Notice that register R13 (stack pointer) is banked;
	there are separate registers for user space and kernel space.
	For registers, aliases are written in parenthesis, and for purpose, calling convention is written in parenthesis.}
	\label{tab:registers}
\end{figure}
As added complexity, the Cortex M4 utilises two different stack pointers, the Master Stack Pointer (MSP) and the Process Stack Pointer (PSP).
The MSP is intended for kernel space execution and the PSP is intended for user space execution, but there is no enforcement.
Switching between the two cannot be done in an exception handler, but must instead be done by the NVIC.
Since the path to the new context goes through the NVIC, the NVIC is also partially responsible setting the state of the processor.
This is done by loading an EXC\_RETURN value into the Program Counter. See table \ref{tab:exc-return} for the different values.
To make context switching transparent to the applications running, it's important that the state the processor returns to, is the
same it earlier came from. Therefore, upon entry into the interrupt routine, the NVIC loads the appropriate EXC\_RETURN into the Link
register. This value must be saved by software to assure it can return to the right state.
\begin{figure}
	\centering
	\begin{tabular}{|c|p{10cm}|}
		\hline
		Value			&	Description 	\\
		\hline
		0xFFFF FFF1 	&	Return to Handler mode, using the Master Stack Pointer, but without the floating point unit.	\\
		\hline
		0xFFFF FFF9		&	Return to Thread mode, using the Master Stack Pointer, but without the floating point unit.		\\
		\hline
		0xFFFF FFFD		&	Return to Thread mode, using the Process Stack Pointer, but without the floating point unit.	\\
		\hline
		0xFFFF FFE1		&	Return to Handler mode, using the Master Stack Pointer, with the floating point unit.			\\
		\hline
		0xFFFF FFE9		&	Return to Thread mode, using the Master Stack Pointer, with the floating point unit.			\\
		\hline
		0xFFFF FFED		&	Return to Thread mode, using the Process Stack Pointer, with the floating point unit.			\\
		\hline
	\end{tabular}
	\caption{
		A table of the possible EXC\_RETURN values. An interrupt service routine is exited by loading one of these values into the Program Counter register.	}
	\label{tab:exc-return}
\end{figure}

\subsubsection{Interpartition communication}

\section{XML}


\section{Memory Management}
ARINC 653 advertises time and space separation covered in.
\todo[inline]{ref to sec in analysis}
To accommodate for the feature of separating partitions in space,
this operating system relies on the memory management unit (MPU)
to manage permissions across sections of memory,
ensuring that partitions stay within a dedicated memory space.

\subsection{something about ARINC on memory management}
The ARINC 653 standard OS, uses a statically allocated memory layout for everything
that gets compiled.
\todo[inline]{reference to standard}
This means that no memory allocation is permitted at runtime
outside predefined memory sections.
This policy ensures a fixed and predictable sandboxing environment, where partitions
can not restrict other parts of the system by occupying memory resources.
It also gives the system developer a way to ensure that the system has enough memory
for all processes to function correctly, given that this amount can be predetermined.

Memory regions are declared in the XML file, included at compile time, for a list
of different system features, like individual partitions and communication buffers.
All of this information is important for different reasons when setting up the system.
The rest of this section will deal with the subject of managing memory regions on a STM32F415 chip
and categorizing and analysing the memory requirements into a single memory strategy to implement in
\todo[inline]{ref to memory management implementation}.

\subsection{the MPU on a STM32F415}

\subsection{memory strategy}
