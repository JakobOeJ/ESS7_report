%! tex root = ../master.tex

\chapter{System Design}
\label{chap:system_design}

In this chapter the project is further analysed. Diagrams are given
and other notions are described, setting up the premises for implementing
\OSname{} based on the \arinc{} standard.

\section{System Overview}
As a means to both explaining the system and as a practical development
model, the system can be thought of as being made up of layers.
Each layer being an abstraction of workings in the layers beneath it,
with the partitions at the top and the hardware at the bottom.
The model in \ref{fig:simple_system} is defined by the \arinc{} standard
and expanded upon here with drivers being build on top of the HAL library,
instead of directly on top of the hardware, creating an extra layer of
 abstraction.

\begin{labeling}{HAL and CMSIS}
	\item [\textbf{Partitions}]
		independent program units that contain applications. These
		applications can in turn interact with other systems. The
		partitions are achieving this while separated from one another.
	\item [\textbf{APEX}]
		defines the methods by which the partitions talk to other 
		modules and
		interact with other partitions or the OS, running
		on the same core module or connected to other ARINC systems.
	\item [\textbf{OS}]
		provides the infrastructure for partitions to operate. This 
		includes their scheduling, message passing and processes 
		the APEX calls.
	\item [\textbf{XML}]
		contains the data necessary for the system initialisation.
	\item [\textbf{Drivers}]
		define the way the hardware should run.	
		They serve the OS with methods to create an environment in which
		partitions can be run and scheduled without influencing one
		another.
	\item [\textbf{HAL and CMSIS}]
		are libraries that provide hardware abstraction layers for
		setting up the hardware. 
	\item [\textbf{Hardware}]
		the physical platform on which the OS is run. This 
		includes the CPU and its peripherals.
\end{labeling}

\begin{figure}[H]
\centering
\includegraphics[width=7cm,keepaspectratio]{simple_system_architecture.pdf}
\captionof{figure}{A simple system overview}
\label{fig:simple_system}
\end{figure}

In the rest of the chapter the different layers are described,
from bottom up, 
together with their core components. The hardware specifications
are outlined, as well as explaining how the rest of the system is
set up.


\section{Hardware}

As mentioned in the \nameref{section:settleing_platform} section,
the hardware used for the development of this system is the Mini-M4
board. It is build around the STM32F415RG microcontroller
\cite{stm32_datasheet}, based on
an ARM Cortex-M4 core. This is a 32-bit RISC architecture CPU using 
the ARM intruction set \cite{arm_architecture}. Additional information
was found in the ARM technical reference \cite{arm_technical} 

The chip provides two interfaces for debugging:
%page 1683 reference manual
\begin{itemize}[noitemsep]
	\item JTAG Debug Port (JTAG-DP)
	\item Serial Wire Debug Port (SW-DP)
\end{itemize}
There was no thought process involved in choosing one of the two.
The JTAG interface is enabled by default, and worked right from the
early phases of the project. In some situations, SW would have been
preferred to JTAG, due to physical space constraints. JTAG uses 5
wires, while SW only 2. Also, the IDE of choice can have some limitations 
on the debugging platform.
\todo{Can I reference to something like this : <http://ieeexplore.ieee.org/document/5412866/>}

JTAG is actually an association\footnote{Joint Test Action Group} 
that develops standards about how 
physical circuit boards should be tested. However, for the rest of
the document, JTAG will be referred to as the main communication interface
to the Mini-M4 board. This will mainly be used for flashing the program
on the chip and debugging it. In order for a computer to access this
interface, the STLINK-V2 in-circuit debugger/programmer \cite{st_link}
is used, through USB.

Another way of communicating with the chip is the serial communication.
For this purpose the UART will be used. This is a common peripheral for 
embedded devices, but it needs to be set up before it can be used. This
involves initialising the UART, configuring the data format and the
transmission speed and sending the actual data. In order to see this data
on a computer, one could use a serial-to-USB adapter \cite{ttl_usb}.
This creates a virtual COM (Communication port), that is accessed using
a serial console such as PuTTY\footnote{Free and open-source terminal emulator, serial console and network file transfer application}.
\\\\
The final setup of the Mini-M4 board comprises of the 5 wires from the JTAG,
the 2 wires from the UART, the mini-USB cable that provides power and a
breadboard to accommodate electrical connections.
\todo{how to write this in the context of system design(the verbal tense)}

\section{Memory Map}
\label{sec:memory_map}
The STM32F415RG microcontroller has 1 MB of flash memory. The flash 
is non-volatile memory, used for storing programs and
data.

There are 192 KB of RAM, divided into 128 KB of SRAM and 64 KB of 
CCM data RAM.
The SRAM is volatile memory, where the $static$ tag means 
that it does not need to be refreshed in order to
keep its state. This is divided furthermore into a section of 112 KB, and 
another of 16 KB, which can be useful if one needs to boot from RAM
\cite{run_from_ram}. Anyway, they are adjacent in address space and can be
treated as one block.
The memory has a feature called bit-banding , in order to let the system
perform atomical operations on bits \cite{bit_banding}.

The other 64 KB of CCM data RAM are always ready for access by the CPU,
but cannot be accessed by the peripherals through direct memory access.
Beside the 192 KB of SRAM, there are 4 KB of SRAM used for backup purposes.
These won't be used, since they are not the scope of the project.

Figure \ref{fig:memory_model} presents a simplified model of the 
memory map implemented in the STM32F415RG microcontroller
\cite{stm32_datasheet_74}. The blocks
\todo{can't get the page referenced PAGE 74}
on the left column are legacy of the ARM Architecture. This provides 
4 GB of addressable memory in all.
These regions are correlated to the microcontroller\textquotesingle s
actual memory, as it can be seen in the column on the right. Each block
in this column contain their start and end addresses, on their side.

\begin{figure}[H]
\centering
\includegraphics[width=\linewidth,keepaspectratio]{memory_model.pdf}
\captionof{figure}{Memory map}
\label{fig:memory_model}
\end{figure}


The input/output are mapped as well in the memory. This can be seen in
the upper two blocks of the memory map, where there are the 
microcontroller\textquotesingle s peripherals, as well as the Cortex-M4
specifics.

\section{HAL and CMSIS}
These two libraries are truly the workhorse when dealing with the 
board\textquotesingle s peripherals. By using them, the development
process usually has a quick start, removing the steepness of the 
learning curve.	\\
HAL stands for Hardware Abstraction Layer and is provided by the chip manufacturer - STMicroelectronics. The source files are available at
their website, along with its documentation \cite{HAL_library}.
The CMSIS (Cortex Microcontroller Software Interface Standard)
can be seen more as a framework, than a library
 \cite{CMSIS_core_library}. It is provided
by ARM, the company that developed the chip architecture.

As seen in figure \ref{fig:CMSIS_HAL}, CMSIS
defines the data structures and address mapping of all peripherals.
Besides this, it can be used to configure the microcontroller
oscillators, as well as providing support for the instrumentation trace during debug sessions \cite{cmsis_reference}.
The HAL library can then use these definitions for implementing its
utilities. One could easily say that HAL is build on top of CMSIS.
This can be further understood by looking at the way CMSIS handles
the exceptions occurring in the chip, while the HAL library configures
these interrupts.

 
\begin{figure}[H]
\centering
\includegraphics[width=\linewidth,keepaspectratio]{HAL_CMSIS.pdf}
\captionof{figure}{The structure of the libraries (inspired by: 
\cite{cmsis_picture})}
\label{fig:CMSIS_HAL}
\end{figure}

\section{Drivers}

The drivers controlling the hardware would have to be implemented at an 
early stage of the project, in order to have access to the low level
subsystems.
The following list contains the drivers that would provide the OS a basic
interface to access the hardware.

\begin{labeling}{Watchdog timer}
	\item [\textbf{System Clock}] provide the frequency at which the
	peripherals are synchronised. This can later on be scaled up or down
	to generate the CPU\textquotesingle s and peripherals\textquotesingle
	\ \ clock.
	The system clock relies on an oscillator.
	There is a multitude of choices, ranging from internal or external
	oscillators, to high or low speed crystals. In some cases, certain
	peripherals can use their own, independent clock sources that also have
	to be configured
	\item [\textbf{UART}] used by the system to communicate with the outside
	world. This can either receive or transmit data to another UART device
	\item [\textbf{LEDs}] mainly used for debugging. They are
	connected to two of the GPIO pins
	\item [\textbf{Delay}] is a simple function, based on calling another
	function from the HAL library. It delays the execution 
	of the program by a factor of milliseconds. Mainly used for debugging
	\item [\textbf{MPU}] provides the system a way to manage its
	memory. This is required by the ARINC 653 standard. 
	Operating systems built on more advanced processors generally use 
	an MMU
	\item [\textbf{Timing}] has the purpose of keeping track of 
	relative time. As the standard specifies, it should be counting 
	nanoseconds
	\item [\textbf{Watchdog timer}] necessary to ensure recovery
	in case of a hardware fault or program error. If this happens, the
	program would be restarted from a safe state
	\item [\textbf{RTC}] has the purpose of keeping track of 
	time accurately. Usually it uses  a 32,768kHz oscillator as a 
	clock source, which is the standard in the field
\end{labeling}

These drivers should be implemented as standalone .c files. They could then
be used by including their header files where needed and calling their
functions.
The basic functionalities of a driver are:
\begin{itemize}[noitemsep]
	\item initialisation of the peripheral
	\item usage of its resources
	\item de initialisation (if needed) \todo {spelling}
\end{itemize}

\section{OS}
The OS kernel has the purpose to link the APEX interface with the hardware.
This is a monolithic kernel. The following sections contain
the kernel\textquotesingle s features and functionalities.

\subsection{Scheduler}
\label{ssec:design_scheduling}
Schedulers are used to allow a system to run more processes than there are
available CPU core. 
A scheduler decides which process should be executed by the processor available
at any given time, according to predefined rules. Based on these rules, two more
more processes may run concurrently, sharing CPU time. The ARINC 653
specification defines 2 levels of scheduling, a partitions level scheduler and a
process level scheduler, and the algorithms for both are strictly defined.\\

The partition level scheduler uses a manual scheduling. Time is split into fixed
length intervals, major frames. Each partition is given one or more windows
(i.e. time slices) in each the major frame. Each window has a start time
relative to the time of the major frame and a duration. Windows are set up by
the system integrator in the XML file.\cite{arinc_part_scheduling}
When a partition has run for the duration it is specified, the scheduler will
switch to the partition of the next window. The switch will happen regardless of
what the partition is doing at that time; a partition cannot overrun its
allotted time and thereby cause other partitions to overrun their deadlines.\\

The process level scheduler is a pre-emptive priority scheduler. All processes 
will at all time have a priority. Processes can only be scheduled when the
partition they belong to is scheduled by the partition level scheduler. The
process scheduler selects the process with the highest priority that is also
in the ready state. If two or more processes have the same priority, the one
that first became ready is scheduled.\cite{arinc_pro_scheduling}\\

The ARMv7M architecture has two special interrupts that are especially useful
for scheduling: SysTick interrupt and PendSV interrupt. The SysTick interrupt is
triggered in a regular interval, and can be used for time based scheduling. The
PendSV interrupt is triggered by software itself and it can be used to trigger 
scheduling from other interrupt service routines, e.g. when a process blocks to
wait for something.

\subsubsection{Context switching}
Context switching is to switch from executing one block of code $b_1$ to another block of code $b_2$
with the intend to eventually return to $b_1$ in a way that is transparent to the blocks of code.
This allows for code to be partitioned into separate independent blocks that can run concurrently.
This is opposed to monolithic blocks of code that entirely control the flow of execution.
Therefore, context switching is essential for any operating system that wishes to utilise a scheduler to allow concurrent execution of code.
Context switching works by saving the state of the CPU registers from one context to memory,
and then switching to another context by restoring the state of the registers previously saved in memory.
Since context switching must manipulate registers directly and individually, it is a feature that must be implemented
on a very low level of abstraction, and it can change significantly from one CPU architecture to another.
The scope of this project is to only implement an operating system for a Cortex M4. Hence context switching needs only
to work on the architecture used by this chip.\\
Context Switching on the Cortex M4 is partially handled by the Nested Vectored Interrupt Controller (NVIC).
When an exception (this includes interrupts) occurs, the NVIC will change context to an exception handler.
Upon changing context from regular code to the exception handler, the NVIC will save the registers R0-R3, R12, LR, PC and PSR
on the stack. These are only some of the registers. Why the decision was made to make the hardware save some of the
registers instead of letting software handle all, is unknown. \todo{Research harder the reason why the NVIC saves some register.}
When the exception handling routine exits, and control is handed back to the NVIC,
the NVIC will restore these registers again.\\
If the operating system wishes to switch context, it must save the remaining registers, R4-R11, and the stack pointer to memory
pick a new context to restore, reload the registers R4-R11 and the stack pointer of the new context from memory,
and hand back control to the NVIC. The NVIC will then reload the remaining
registers from the stack of the new context. To see a figure of the registers
and who saves them, see table \ref{tab:registers}\\

\begin{table}[H]
	\centering
	\begin{tabular}{|c|c|p{9.5cm}|}
		\hline
		Register	&	Saved by	&	Purpose\\
		\hline
		R0			&	Hardware	&	General purpose (Argument value + return value)\\
		\hline
		R1-R3		&	Hardware	&	General purpose (Argument value)\\
		\hline
		R4-R11		&	Software	&	General purpose (Local variable)\\
		\hline
		R12			&	Hardware	&	General purpose (Intra-Procedure-call scratch)\\
		\hline
		R13 (SP)	&	Software	&	Stack pointer [Banked]\\
		MSP			&	Software	&	Master stack pointer (Stack pointer for kernel space)\\
		PSP			&	Software	&	Process stack pointer (Stack pointer for user space)\\
		\hline
		R14 (LR)	&	Hardware	&	Link register\\
		\hline
		R15 (PC)	&	Hardware	&	Program Counter\\
		\hline
		xPSR		&	Hardware	& 	Special-purpose Program Status Register\\
		\hline
	\end{tabular}
	\captionof{table}{A table of the CPU registers of a Cortex M4. Notice that register R13 (stack pointer) is banked;
	there are separate registers for user space and kernel space.
	For registers, aliases are written in parenthesis, and for purpose, calling convention is written in parenthesis.}
	\label{tab:registers}
\end{table}

As added complexity, the Cortex M4 utilises two different stack pointers, the Master Stack Pointer (MSP) and the Process Stack Pointer (PSP).
The MSP is intended for kernel space execution and the PSP is intended for user space execution, but there is no enforcement.
Switching between the two cannot be done in an exception handler, but must instead be done by the NVIC.
Since the path to the new context goes through the NVIC, the NVIC is also partially responsible setting the state of the processor.
This is done by loading an EXC\_RETURN value into the Program Counter. See table \ref{tab:exc-return} for the different values.
To make context switching transparent to the applications running, it's important that the state the processor returns to, is the
same it earlier came from. Therefore, upon entry into the interrupt routine, the NVIC loads the appropriate EXC\_RETURN into the Link
register. This value must be saved by software to assure it can return to the right state.


\begin{table}[H]

	\centering
	\begin{tabular}{|c|p{10cm}|}
		\hline
		Value			&	Description 	\\
		\hline
		0xFFFF FFF1 	&	Return to Handler mode, using the Master Stack Pointer, but without the floating point unit.	\\
		\hline
		0xFFFF FFF9		&	Return to Thread mode, using the Master Stack Pointer, but without the floating point unit.		\\
		\hline
		0xFFFF FFFD		&	Return to Thread mode, using the Process Stack Pointer, but without the floating point unit.	\\
		\hline
		0xFFFF FFE1		&	Return to Handler mode, using the Master Stack Pointer, with the floating point unit.			\\
		\hline
		0xFFFF FFE9		&	Return to Thread mode, using the Master Stack Pointer, with the floating point unit.			\\
		\hline
		0xFFFF FFED		&	Return to Thread mode, using the Process Stack Pointer, with the floating point unit.			\\
		\hline
	\end{tabular}
	\captionof{table}{
		A table of the possible EXC\_RETURN values. An interrupt service routine
		 is exited by loading one of these values into the Program Counter register.	}
	\label{tab:exc-return}
\end{table}

\subsection{Interpartition communication}
Interpartition communication as introduced in section \ref{ssec:interpart_comm} is a basic mechanism for linking partitions by messages with channels.
Each partition can be linked to multiple channels by ports.
A partition can interact with its ports by using the APEX and send or receive messages.

At the application level messages are atomic and as such channels are required to insure the correctness of every message received \ref{}.
Multiple different modes exist for the messages and different checks and methods should be applied to comply with the ARINC 653 standard.
Only a subset of these features is designed and implemented,
to give a basic feature set which allows partitions to communicated on a single MCU.

A simplified design of queuing ports and sampling ports is designed for open653.

Since ports and their attributes are declared and defined statically,
very little has to be done to initialize them at startup.
Ports are organized as belonging to some partition and some channel
and have some common port attributes as well as some attributes belonging to their port type.

Some necessary common port attributes for for ports is:
\begin{itemize}
	\item The port name
	\item Some flag indicating wheather a port is a of type queuing or sampling
	\item A port direction attributed indicating whether the port is a destination or a source
	\item Maximum message size
	\item A reference to the channel it belongs to
\end{itemize}

A port can be viewed as belonging to some partition,
hence ports can be structured in multiple arrays,
with each array containing the ports belonging to a particular partition.
This way of structuring result in every port having to contain a reference to its channel, as started in the above list.

Some necessary attributes for queuing ports and sampling ports are listed in
the sections \ref{sssec:queuing_ports} and \ref{sssec:sampling_ports} respectively.

\subsubsection{Queuing Ports}
\label{sssec:queuing_ports}
The necessary attributes for queuing ports secifically are the following:
\begin{itemize}
	\item Number or messages received in the queue
	\item Maximum number of messages to be hold by the receive buffer
	\item A circular buffer to act as the FIFO buffer
\end{itemize}

The OS has to facilitate some methods to push and pop complete messages to and from a circular buffer,
which would be defined auto-generated from the XML configuration file.
Open653 also has to provide functions to handle the following APEX calls defined in the standard \cite{arinc_interpartition_comm}:

\begin{itemize}
	\item CREATE\_QUEUING\_PORT
	\item SEND\_QUEUING\_MESSAGE
	\item RECEIVE\_QUEUING\_MESSAGE
	\item GET\_QUEUING\_PORT\_ID
	\item GET\_QUEUING\_PORT\_STATUS
\end{itemize}

\subsubsection{Sampling Ports}
\label{sssec:sampling_ports}
The necessary attributes for sampling ports secifically are the following:
\begin{itemize}
	\item A refresh period time
	\item An indicator for the validity of the last received message
	\item A buffer to hold the sampling message
\end{itemize}

The OS has to facilitate some methods to transmit and validate sampling messages.
A simple buffer has to be provided for this by the auto-generated structures.
Open653 also has to provide functions to handle the following APEX calls defined in the standard \cite{arinc_interpartition_comm}:

\begin{itemize}
	\item CREATE\_SAMPLING\_PORT
	\item WRITE\_SAMPLING\_MESSAGE
	\item READ\_SAMPLING\_MESSAGE
	\item GET\_SAMPLING\_PORT\_ID
	\item GET\_SAMPLING\_PORT\_STATUS
\end{itemize}


\subsection{Memory Management}
ARINC 653 advertises time and space separation covered in.
\todo[inline]{ref to sec in analysis}
To accommodate for the feature of separating partitions in space,
this operating system relies on the memory management unit (MPU)
to manage permissions across sections of memory,
ensuring that partitions stay within a dedicated memory space.

\subsection{something about ARINC on memory management}
The ARINC 653 standard OS, uses a statically allocated memory layout for everything that gets compiled.
\todo[inline]{reference to standard}
This means that no memory allocation is permitted at runtime
outside predefined memory sections.
This policy ensures a fixed and predictable sandboxing environment, where partitions can not restrict other parts of the system by occupying memory resources.
It also gives the system developer a way to ensure that the system has enough memory for all processes to function correctly, given that this amount can be predetermined.

% This figure should NOT be placed near a pagebreak.
% Otherwise it fucks everything up!
% If thats not okay, use normal figure instead.
\begin{wrapfigure}{R}{0.3\textwidth}
	\vspace{-20pt}
	\centering
	\includegraphics[width=0.3\textwidth]{mpu_overlapping_regions.pdf}
	\caption{Example of nested and overlapping regions from \cite{stm32_mpu}.}
	\label{fig:stm32_mpu}
	\vspace{-40pt}
\end{wrapfigure}

Memory regions are declared in the XML file, included at compile time, for a list of different system features, like individual partitions and communication buffers.
All of this information is important for different reasons when setting up the system.
The rest of this section will deal with the subject of managing memory regions on a STM32F415 chip and categorizing and analysing the memory requirements into a single memory strategy to implement in \todo[inline]{ref to memory management implementation}.

\subsection{the MPU on a STM32F415}
The memory protection unit (MPU) can be used to prohibit partitions from corrupting data used by kernel code and other partitions.
The MPU can protect up to eight memory regions and is unified, meaning that it doesn't distinguish between code sections and data sections.
Regions can have sub-regions but because the minimum (sub-)region size is the size of a cache line length (32 bytes), sub-regions is only available for regions of at least 256 bytes of size.
Partitions above this threshold can have eight sub-regions.\\

Every region have a fixed priority and is numbered from 0-7, where region 7 has the highest priority.
Regions can be nested and overlap.
The behavior when nesting and overlapping is dictated by the priority of the region as shown in figure \ref{fig:stm32_mpu}.

\subsection{memory strategy}
As the memory available is not abundant, there is the need of avoiding wasting memory. For that, the memory needed by the partitions is optimized by a sorting algorithm in order to fit 
the most partitions possible in a limited region of memory and by expanding the partition size fullfilling 
the empty gaps. It is important to keep the size, initial pointer and the region of each partition for enable and disable the right area of memory when a different partition is active.

\subsection{System calls}
To improve security and robustness, many modern operating systems make clear 
distinctions between the kernel and applications, and they restrict application
code from accessing certain periphrial hardware (e.g. storage devices, I/O
devices, etc.) as well as control registers of the CPU. 
To restrict only certain code from certain features requires hardware support.
To accomplish this, many modern CPUs contain two or more different execution
levels. Normally, the kernel will run in the most privileged execution level
while application code runs in a more restricted execution level. This prevents
application code from changing the state of any resources shared with other
application. This is critical to accomplish ARINC 653's strict space and time 
seperation. If partition level code is not run in an unprivileged mode, it will
be able to directly change the CPU time and memory space allocated to it. This
would negatively affect the partition the resources were stolen from. However,
since partition level code does on occation need access to some shared resources,
yet is unable to do so directly, it must request the kernel do it. To do this,
partition level code must preload the general purpose CPU registers, and if
necessary the stack, with a value to identify what the partition wishes the
kernel do, as well as call arguments, then generate an interrupt which will be
caught by the kernel. Based on the content of the general purpose CPU registers
and the stack, the kernel determines what the partition level code requested,
executes the necessary functions and returns the result in the general purpose 
CPU registers and the stack.

\section{Schema}
\label{sec:design_schema}
An ARINC 653 schema specifies the structure 
of the configuration and the required elements 
for the core module to operate.
The schema is a recipe used to create the file 
that will contain the configuration.

\subsection{Schema design}

The schema defined is not the complete 
ARINC 653 schema, though it can be extended 
into the full schema with some more work. 
The scope was limited as outlined in the
problem statement. \ref{chap:Problem_Statement}) 

\begin{figure}[H]	\includegraphics[clip=true,trim=0cm 20cm 0cm 0cm,width=\linewidth,keepaspectratio]{figures/open653schema.pdf}
	\caption{open653 schema design}
	\label{fig:open653schema}
\end{figure}

The figure represents the schema and the 
relationship between the elements. 
An ARINC 653 Module has five elements. 
One or more Partitions, a Connection Table, 
one or more Partition Memory elements, and 
a Module Schedule.
\\\\
Each partition has five attributes, and zero 
or more sampling and queuing port elements. 
PartitionIdentifier is the unique ID for the partition. 
PartitionName is the name for the partition. 
Criticality specifies the importance of the partition.
SystemPartition is a boolean specifying if the partition 
is a system partition or standard partition. 
EntryPoint is the name of related partition function name.
\\
Sampling or queuing ports each have a unique 
attribute, and share common attributes defined 
by PortType. 
PortName is the name of the port. 
MaxMessageSize is
Direction is 
MaxNbMessages is
\\\\
Each Partition\_Memory has two attributes, 
and one or more Memory\_Requirements.
PartitionIdentifier is the unique ID for the partition memory.
PartitionName is the name for the partition memory.
\\
Memory\_Requirements each have five attributes.
Type is
SizeBytes is 
Access is 
PhysicalAddress is
\\\\
Module\_Schedule is made up of one or more Partition\_Schedule elements, which in turn are made up of one or more Window\_Schedule elements. Module\_Schedule has one attribute which defines the major frame rate for scheduling each partition. 
\\
Partition\_Schedule has four attributes
\\
Window\_Schedule has four attributes
\\\\
A Connection\_Table has no attributes and one or more channels.
\\
A Channel has two attributes, and one or more source or destination channels which share common attributes defined by Standard\_Partition. 
\\\\

\subsection{Full ARINC 653 schema}

\begin{figure}[H]
	\includegraphics{figures/originalschema.png}
	\caption{full ARINC 653 schema}
	\label{fig:arinc653schema}
\end{figure}

\todo{add ARINC standard reference}
The figure shows the intended schema for a fully compliant ARINC 653 implementation as found in the ARINC standard.  The greyed out areas, are the aspects of the open653 schema not yet implemented in this project. 

\subsection{Schema translation}

XML is the chosen configuration file format. XML was chosen as opposed to alternatives due to its easy to read and write nature, ARINC\textquotesingle s XML example providing guidance and previous experience with XML in the project group.

\section{APEX}

\section{Partitions and processes}

\subsection{Partitions}

\subsection{Processes}

\subsection{Error Handling}

\section{Agile development}
The software development process flowed naturally due to previous 
experience, curiosity and personal interests. The nature of the project
allowed the team to cover different areas at the same time, while still
doing progress, without having a strict plan. Seen as a whole, the project
was pursued by applying the principles of agile software development.
\todo[inline,color=green]{Maybe move this section somewhere else.}

\section{Discussion}

Figure \ref{fig:advanced_system} presents the system in its entirety,
with all the components organised in the corresponding layers.


\begin{figure}[H]
\centering
\includegraphics[width=\textwidth]{advanced_system_architecture.pdf}

\caption{An advanced system overview}
\label{fig:advanced_system}
\end{figure}

The following chapter will go through how all these components,
features and functionalities has been implemented.
