\chapter{Testing}

\section{MPU}
In order to test the memory partition mapping, the sorting memory algortih is applyed and the final memory distribuition printed in the terminal. For 
that it's setted an amount of free memory and a random initial pointer, representing the begining of the memory free 
space. It's defined specific sizes for each partition and the sorting memory algorith is applied to those 
conditions. Everytime that a partition is allocated, in all its memory positions is written the number of 
the partition. In the the output will be shown the space given to each partition and location in the 
memory map by the number written in each position.\\
As the sorting algorithm covers different possibilities of partition distribuitions, according to the 
number of spare subregions (0, 1, 2 or 3), it is tested for those 4 possibilities. One of the examples is 
shown in the image below.\\
  The results printed showed us that the new sizes and subregions distribution of the partitions before and after the algorithm. The results obtained are exactly like the expected from the mapping algorithm.

\begin{figure}[H]
\centering
\includegraphics[width=15cm]{mpu_test.png}
\captionof{figure}{Terminal displaying the results}
\label{fig:testing_mpu}
\end{figure}


\section{XML validation}
Currently there is no validation of the XML file.
The XML is currently prone to human error when manually
adding to the file, also it does not prevent elements
not compliant with the schema being written.


\section{Scheduler}
The scheduler has been tested to work provided the XML file specifies reasonable
windows. The scheduler has not been tested with edge cases.\\
The kernel does not record any runtime metrics. Empirical
evidence shows that the scheduler is working according to the windows specified in the
XML schema and according to the designed algorithms. Window durations is
scaled up to make it possible with the human eye to determine that the scheduler
indeed follows the windows.


\section{\arinc{} specification - Part 3}
In order to test a system for compliance with \arinc{},
the authors of the standard provide a conformity test
specification. This is a separate document, as a part of the
\arinc{} specification:
\begin{itemize}
	\item\textbf{Part 0} Introduction to ARINC 653
	\item\textbf{Part 1} Required services. This includes system services,
	data structures and functional behaviour.
	\item\textbf{Part 2} Extended services. For example file handling or external events
	\item\textbf{Part 3} \textbf{Conformity test}
	\item\textbf{Part 4} Subset Services
	\item\textbf{Part 5} Core Software Recommended Capabilities
\end{itemize}

Software developers should use this to test the compliance with
Part 1 of the standard. This could be done in the future phases of the \OSname{} OS in order
to demonstrate full compliance of the APEX behavior.


\section{Interpartition Communication}
Interpartition Communication is tested for queuing ports, not sampling ports.
The test is done with the three partitions \texttt{red\_toggler},
\texttt{yellow\_toggler} and \texttt{stdio\_sys}. \texttt{red\_toggler} and
\texttt{yellow\_toggler} broadcast their respective partition name as a string
to the \texttt{stio\_channel}. The \texttt{stdio\_sys} reads any message within its
time-frame and transmits the strings by UART to a connected terminal. Both
transmitting partitions are set to transmit their string every two seconds. A
sample of a recorded output is depicted in figure \ref{fig:message_test},
showing that the communication scheme works as intended.

\begin{figure}[H]
	\centering
	\includegraphics[scale=0.5]{message_test.png}
	\caption{Terminal showing the strings originating from two different
		partitions.}
	\label{fig:message_test}
\end{figure}

As can be seen from the figure, the \texttt{yellow\_toggler} is sending twice as
many messages as \texttt{red\_toggler}. This is due to the scheduling of the two
partitions. The file main\_schema.xml shows that both partitions are
scheduled to execute twice within the major time-frame of 20 seconds, but that
\texttt{yellow\_toggler} is given twice the time of \texttt{red\_toggler} at
every interval and hence gets to print more often.\\

Even though the sampling port module is implemented in the codebase, it is yet
to be fully integrated into \OSname{} and therefore is not tested.
