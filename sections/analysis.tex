%! tex root = ../master.tex

\chapter{Analysis}\label{chap:analysis}
This chapter includes information about 
the standard and how it is going to be implemented.
Requirements for the standard are analysed, 
and decisions of hardware, software and 
existing platforms are considered
to formulate the project scope.

\section{Real-time systems}
A real-time system is handling data as it comes in.
Besides the usual computations needed to be done,
the time until a result is generated is also important.
This means that the applications are scheduled in a manner 
that would allow them to respond quickly and predictable.
Real-time systems are developed in order to answer 
requirements of different fields of work
where time is critical: military, automotive or aeronautics.

\section{Integrated Modular Avionics}
In the aeronautic industry, the devices and subsystems used for
controlling the peripherals have to be reliable and operate using
fixed time constraints. Integrated Modular Avionics is a term used
to describe a distributed real-time computer network deployed for
use in the avionics industry \cite{ima_description}.
Modularity, keeping track of the time and criticality levels are
the main characteristics of such a network.
This implies that the applications running would share the 
system\textquotesingle s resources following a set of well defined rules.

There are guidelines of how such a system should be designed and
implemented, as well as standards that specify how space and time 
should be partitioned.

\todo{Include the benefits : significant benefits, i.e. aircraft weight reduction
and lower maintenance costs}

\section{ARINC 653}
\arinc{} is a software specification that allows a system to host 
multiple avionics applications on the same hardware while being able
to execute them independently. This is achieved by partitioning the
system \cite{arinc_2}.

\subsection{Overview}


\arinc{} is said to \textit{bring a new quality in real-time systems development} \cite{arinc_scarlett}.
This is achieved through its API (called APEX) which interfaces between the OS and the software applications.
The APEX manages partitions, memory allocation and error handling.
Applications are partitioned separately into these partitions with their own memory and scheduled processing time slots.
These partitions cannot interfere with each other and can not take resources from each other.
If an error in a partition occurs, it will only crash itself; the remaining partitions will not be affected.

The following is a brief description of what the standard specifies.

\subsection{Modules}
The term module refers to the aviation concept of IMA, thus a module
can be seen as a piece of hardware, controlling other subsystems.
A module can contain one or more processors. However, this does not fit 
well with the concept of partitions,
which have to run on one processor. \cite{page_11}
A processor used for ARINC applications should have sufficient processing
power and access to I/O, memory and time resources. Besides
this, the processor should be able to isolate a partition from
the others, if it fails.
\cite{page_12}

\subsection{Partitions}
A partition is a program unit designed to obey space and time limitations
set by the developer. The way partitions are being run by the processor,
is in a static, cyclic manner meaning that they do not have any priorities.
One partition should only have writing rights to its own memory space. 
\cite{page_13}
The resources used by the partitions are specified at build time.
\cite{page_14}
The standard differentiates between partitions that run applications and system partitions. The latter are optional, and can be used to contain
services not provided in the APEX \cite{scarlett_page_3}.

\subsection{Processes}
These are the parts of program running on partitions. One partition
may contain one or more processes. These may operate concurrently,
and may operate in a periodic or aperiodic manner. A process's 
characteristics are: data and stack areas, program counter, stack pointer,
and maybe priority and deadline. These attributes can either be fixed 
or variable. The fixed attributes are statically defined, and cannot
be changed during operation.
\cite{page_19}
Process management is done with the use of APEX calls.
Processes can be in different states: dormant, waiting, running, ready.
Their scheduling is done in such a way that the process in the ready state
with the highest priority is always executing when the partition is active - priority preemptive.
\cite{page_20}

\subsection{Time}
Time management is very important in real-time systems.
Time keeping is needed for partition and process scheduling,
as well as for delays, deadlines and periodicity.
Partitions receive time-slots during system configuration.
Processes receive time capacity (meaning that they are expected
to finish before a deadline).
The difference between the two brings the need for having extra APEX calls
to control ad monitor how processes are behaving.
\cite{page_25}

\subsection{Memory}
Memory spaces are defined during the system configuration. These cannot
be changed later on.

\subsection{Interpatition communication}
The \arinc\ specification defines a way for different partitions to communicate with one another.
This communication is based on message passing. To transfer messages between partitions the \arinc\ standard
defines the concepts of channels and ports.

\paragraph{Channels} are logical links spanning partitions. If necessary, 
a channel might logically span different modules. 
\todo{Has modules been defined yet?}
The way for partitions to access a channel, is via ports.
Channels are defined by the system integrator at configuration time.
Channels should be transparent to the application programmer.

\paragraph{Ports} allows monodirectional access to a channel;
a port can either be configured send or receive messages by a partition.
When a message is written to a port, it will remain in a buffer, until the operating system transmits the message to the destination.\\

Two types of ports exist, sampling ports and queuing ports. 
\subparagraph{Sampling ports} employ no form of message queuing; if a partition tries to write more than one message to a sampling port
before they are transmitted through the channel to the destination port, the prior message will be overwritten. Similarly, once a message arrives at the destination port,
it will override any prior messages, regardless of whether it had been read or not. These ports may be used in situations where only the most recent message is important.
\subparagraph{Queuing ports} queue messages both at the sender and at the receiver. Ports in queuing mode may employ a queue buffer to keep more than one message at a time.
When processes send messages they accumulate in the source port queue. At a behest of the operating system, messages in the source port queue will be transmitted to the destination port queue.
When a process reads a message from the destination port, that message will be cleared from the port queue. If the destination queue is filled, no more messages will be allowed
in to that queue until it is emptied. If the destination queue is filled, messages may start to accumulate in the source port queue. If a process tries to send a message through a
source port with a full queue, the process may block until it is cleared, or receive an error.
Process waiting for a queue to have space (source) or to have content (destination), can either wait in a purely FIFO order or a priority based FIFO order, where processes with high priority
will be moved up in the FIFO queue.\\

Messages sent through queuing channels should always be sent in a FIFO manner.
Ports are defined at solely configuration time and are tied to both a certain channel and a certain partition.
It is therefore impossible for application code to define new ports at runtime. 
For a process to access a port, an object representation must be created. This happens through an APEX system call.
The location in memory of port buffers is not specified in the \arinc\ specification.

\subsection{Intrapartition communication}
Allows processes in a partition to communicate to each other. This way
the communication is done more efficiently than having to use a 
global message passing system.
Can be done by implementing buffers and blackboards, or semaphores and 
events.

\subsection{Health Monitor}
Has the purpose of monitoring and reporting hardware and software faults
and failures.
\todo{Include this: Its main task
is to isolate faults and prevent failure propagation. For example, the HM can restart a partition
when detects application fault
\cite{scarlet_page_4}}

\subsection{System configuration}
The OS allows portability and reusability of applications. However,
these applications have to be integrated in the system. This is done
by giving the partitions the access and resources needed, in order to
satisfy the applications\textquotesingle requirements \cite{page_42}.

\subsection{Decision}
The idea is to bring such an operating system in to the wider embedded world.
To do that in a one semester project, the focus will be on understanding the standard,
working with embedded systems and implementing the parts of the operating system that are
essential for running simple partitions on a single hardware unit.

\section{Hardware}

\subsection{The rise of embedded devices}
\todo{The first paragraph reads a bit too hasty. Should be written a bit longer}
In the world of embedded computing the computing platforms varies a lot more,
compared to the world of workstations and desktop computers.
Traditionally, embedded computers are used for small specialized static tasks and
not required to run an operating system with multiple processes.
For this reason many embedded systems are arranged as a SoC,
with limited amounts of ram, flash and a low CPU clock,
not capable of supporting large computer screens and high speed networking.
\\\\
Improved technology however, have brought powerful new CPUs of architectures used in the embedded world
such as MIPS and ARM.
The latter now being used in all levels of computing, from ultra low power single purpose embedded systems,
to workstations and supercomputer installations with graphics and high speed networking requirements.
For more powerful computers this might represent both a shift from the widely used CISC architecture
to the smaller RISC architecture and a new focus on power efficiency over increased CPU speed.
\\\\
For embedded devices this change has meant more capable systems
and an increasingly narrowing gap between embedded and workstation computing.
Capable low power devices and cheap manufacturing of this new generation of RISC based computing systems,
has made it possible to build computers to solve problems on all scales using the same, or similar, platforms.
This has brought a surge of development for the middle layer of computing,
a little more capable than traditional embedded devices and a little less capable than the typical workstation.
\\\\
Developing a system to operate in an embedded environment with real time requirements
and low overhead peripheral interaction,
yet with the flexibility and multitasking capabilities of a modern operating system,
puts some lower limits on the capabilities of the hardware.

\subsection{The lower bound on systems}
Overall these requirements must to be met by the hardware:
\begin{itemize}
	\item Be fast enough to run multiple applications and the operating system below
	\item Have sufficient main memory to support the stacks for all running applications and the operating system
	\item Must come with either an MMU or MPU to provide protected regions in memory for separate contexts
\end{itemize}
\noindent
The first two requirements depend almost entirely on the tasks being solved.
The more applications being run and the more resource demanding they are,
the more CPU time and memory they are going to utilize.
The requirement to provide a MMU or MPU to safely segregate blocks of memory between applications and the operating system,
puts a lower bound on the type of hardware required.
\\\\
\todo{Give a more detailed explanation on the difference between an MPU and MMU}
More capable systems may provide a MPU for basic memory protection
The smallest embedded systems typically do not provide any memory protection,
only being required to run single purpose applications where all drivers and interfacing
are compiled and executed as a single binary image.
Ever more powerful systems may come with a MMU,
providing a uniform picture of the memory-space from the viewpoint of every application.

\subsection{Some of the options out there}
The best way to decide on a hardware platform to work on is to explore some of the options out there.
Being a single-semester project with varying degree of experience,
implementing an operating system from scratch;
the hardware should not be in the complex end of what is available.
\\\\
In appendix \ref{app:embedded_devices} is a brief list of hardware platforms listed in no particular order.
Every unit has been selected on the premise of possessing either an MMU or MPU for the space partitioning feature in the OS.
Also the candidates varies to some degree in capability and complexity,
but more than anything; it was just what we could find with a few Google searches.
\todo{Specify the search terms we used to find them.}
\\\\
Four proposed hardware candidates are listed:

\paragraph{Creator Ci40} is a platform meant for IoT development.
It comes with easily available ports and connections for embedded development
and networking over protocols like ethernet and bluetooth.
It is built around the cXT200 chip which is based on a JZ4780 550MHz dual-core MIPS CPU \cite{creator_ci40_specs}.
It comes with an MMU, is capable of running Linux
and is generally more powerful than many low power embedded platforms.

\paragraph{MINI-M4 for STM32} is an ARM Cortex-M4 based development board containing a STM32F415RG microcontroller.
It provides a simple pin layout and fits well into a breadboard for connecting external devices
and comes with a single USB port to deliver power and to be programmed through, with an installed bootloader.
The STM32 chip comes with a MPU and a single core CPU capable of running 168 MHz,
but limited to 120 MHz using the on-board bootloader \cite{MINI-M4_stm32_specs}.
Available is a downloadable hardware abstraction layer (HAL) library from chip manufacturers website,
which comes with a number of implementation examples and documentation \cite{HAL_library}.

\paragraph{MINI-M4 for Tiva} is similar to the MINI-M4 for STM32 above,
based on the same ARM Cortex-M4 architecture,
but using the TM4C123GH6PM chip from Texas Instruments instead.
It has a pin layout similar to the MINI-M4 for STM32,
a USB connection for power and programming and comes with an MPU,
but only runs at 80 MHz \cite{MINI-M4_tiva_specs}.

\paragraph{Raspberry Pi 3,} probably the most well known platform,
based on a 1.2GHz 64-bit quad-core ARMv8 CPU,
making it available for both embedded use and common desktop computing tasks \cite{raspberry_specs}.
The Raspberry Pi lacks any comprehensive documentation on its register layout,
and being a higher end device compared to MINI-M4 and Creator Ci40,
it's presumably more complex to work with.

\subsection{Settleing on a platform}\label{section:settleing_platform}
Obviously a list longer than the one seen above can be compiled.
Although the hardware used is not the primary concern to the project
and as such the goal is to show examples of known platforms,
available for purchase in Denmark,
that all hit within the range of what can be considered embedded devices.
\\\\
The two MINI-M4 devices represent a lower, but capable end of the performance spectrum,
while the Raspberry Pi and the Creator Ci40 are more capable.
All four devices have the necessary features to run a simple low power OS,
but building the OS give practical concerns to the complexity and ease of setup.
\\\\
Focusing on core OS features, only a few basic peripherals
like timers, MPU/MMU, UART and basic IO are necessary for the project,
also the ARINC 653 does not provide a solution to scaling the operating system
or containers across multiple cores,
hence more capable hardware is likely see a low peripheral use.
\todo {rephrase this}
Since the project is focused on the implementation of an OS
and less so the containers running on it.
A low CPU utilization might be seen on more performant systems.
\\\\
The MINI-M4 modules are more attractive choices from the utilization standpoint.
A comprehensive datasheet is available for both of them,
making it easier to program them from the scratch.
Some experience with the STM32 is present within the project group
on how to setup and Linux based tool-chain. The manufacturer of the STM32
provides sample code implementations as well as hardware abstraction
layer libraries, things that would give a head start on the project.
\\\\

\subsection{Decision}
This leads to the decision of using Mini-M4 for STM32 as the hardware
for \OSname{}. For the rest of the document this would be referred as 
"the board", while the STM32F415RG unit as "the microcontroller" or
"the chip".
\todo[inline, color=green] {Make sure this fits in the Hardware section}

\subsection{Communication with the board}
In order to get started with the development of the OS, there is need for
a way to communicate with the board. Due to previous experience with
this type of hardware, the following components have been ordered:

\begin{itemize}[noitemsep]
	\item ST-LINK/V2 in-circuit debugger/programmer for STM8 and STM32
	\cite{st_link} - to give access to the JTAG port
	\item FTDI TTL-232R-3V3 cable \cite{ttl_usb} - to create a communication
	port
\end{itemize}
\todo[inline, color=green]{maybe choice of language should be here??}

\subsection{Helper libraries}
When starting writing software, one needs to decide how to make this
process easy and transparent. This is very dependent of the 
project\textquotesingle s requirements such as time frame, performance, 
security and reusability. One possibility would be to work on the 
"bare metal", and 
use the chip\textquotesingle s Reference guide, and maybe part of the 
ARM Architecture reference manual.

Another way could be to use some libraries that define the I/O and work
on a slightly higher level. ARM provides libraries for their architecture
as well as the vendors providing libraries and examples on how to use their
hardware. 
\todo {I don't specifically mention HAL and CMSIS until the next chapter.
is that fine?} 

\subsection{The legacy from the race car project}
This project has some roots in another project that has been going on
for some years at Aalborg University \cite{aauracing}. 
The choice of hardware was
slightly influenced by this, as well as the tools and libraries used 
throughout the project. The big advantage of this, is that by having the 
experience and knowledge the project could get a head start.
\todo{Maybe Jakob has something to add}

\section{Software}
\subsection{Overview}
An ARINC 653 compliant platform has some strict requirements.
The OS must perform safety critical and time critical tasks that must be separated by space and time.
There are accompanying standards to test and verify a system to determine how well it meets its requirements.

\subsection{Avionics safety standards}

\subsubsection{DO-178}
DO-178 is a set of guidelines to be used for software assurance in safety-critical software in avionics systems.
Use of the standard can determine the reliability of the software in an airborne environment.
There is a ``safety assessment process'' and ``hazard analysis'' to determine the result of failure conditions on the system.
The final result of the standard applied to the software system will give the system a ``software level'' of A to E compliance,
where A is the best level to be achieved and E is the worst.
A level A compliance mean the system has been verified and validated against catastrophic failures,
whereas an E compliance has been verified against trivial failures.
% \subsubsection{DO-254} this standard is the counterpart of DO-178 (seems to do the same thing)
% \subsubsection{DO-297} cant find much on this standard

\subsection{Alternative ARINC platforms}
When considering how to implement ARINC 653 we first explored existing platforms that might meet our needs.
There are COTS (Commercial of the Shelf) OSs, and there are open source OSs.
An existing platform would save us time to get an ARINC platform running,
but with varying levels of limitations between the COTS and open source.

\subsubsection{open source OS platforms}
An existing open source ARINC OS could have potentially worked since its limitations would be minimal
compared to a COTS solution. %Saving time and money to get an ARINC platform running

\subsubsection{ARLX}
% http://dornerworks.com/portfolio/arlx-arinc-653-real-time-linux-xen
% http://genesysideation.com/news/dornerworks-releases-prototype-arinc-653-hypervisor-to-open-source-community/
ARLX is a prototype hypervisor for ARINC 653 which is an extension to the Xen hypervisor.
Linux is used to partition the system.
It has been developed in accordance with DO-178.
% \subsubsection{LithOS} http://www.fentiss.com/en/products/arinc653.html

\subsubsection{COTS OS platforms}
There are several commercial OSs that support ARINC:
VxWorks, PikeOS, LynksOS, WindowsCE, Linux RTAI and CsLEOS OS to name the main ones.
%"eliminates the risk of creating and certifying an operating system for new projects"

\subsubsection{VxWorks}
% important reference1 http://www.windriver.com/products/product-overviews/PO_VxWorks653_Platform_0210.pdf
% important reference2 https://windriver.com/products/product-overviews/2691-VxWorks-Product-Overview.pdf
Called VxWorks 653, is it marketed as ``The Industry's Leading Operating System for Embedded devices''.
It contains an ARINC 653 compliant platform and compliance with DO-178C to level A, DO-254 and DO-297.
Capable of full virtualization on a shared multi-core processor.

\subsection{Decision}
\todo[inline,color=green] {why we did not use any of the Arinc implementations mentioned above?}
Since we decide not to use any of the existing implementations...
the degree of freedom for choosing the hardware is increased.

\section{Programming language choice}
The languages Ada, C and C++ are taken in consideration as an embedded language.
\\\\
Ada was created during the 70's by the Defense Department of the USA.
It was created to reduce the number of
languages used between departments.
It is a high level language,
and with high critical control,
making it safe to be used in airplane software.
\\\\
C is a simple low level language especially popular in embedded systems.
like Ada it was created in the 70's and
overall among the most popular languages used today.
C is easy to use in projects favoring memory and instruction control,
as is the case with ARINC 653,
where resources are allocated statically
so dynamic memory allocation can be avoided.
\todo{do we have a reference on some of this?}
\\\\
C++ is a multi paradigm language described by some as ``C with classes''.
Created in the 90's, it is more an object oriented language than
the imperative C.
\todo{Maybe Anders can fill in a little about what C++ can do
and why that is good/bad?}
\\\\
For the passing of the schema, a higher level language can be used
since it is running on the computer used in development,
hence there is little concern for optimisation and memory usage.
The schema will be translated into a usable format to the embedded system.
Once translated it will be compiled and uploaded to the
embedded system.
\\\\
Python is an easy high level language to use.
There is very little boiler plate code involved,
it is not typecast, nor does it need to compile
before it is executed.
It has many libraries to interact with structured
data types such as XML and JSON,
which makes it a well suited option for developing the schema parser.

\subsection{Decision}
Python is chosen as the language to parse the schema and
C is chosen for embedded development because of its simplicity and
the level of experience within the group, with the language.
